
Original sample:

{"has_bug": true, "bug_kind": 1, "bug_kind_name": "VARIABLE_MISUSE", "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "_type_map", ".", "get", "(", "type", "(", "value", ")", ",", "NULLTYPE", ")", "#NEWLINE#", "if", "(", "(", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "_type_affinity", ")", ")", ":", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"], "error_location": [36], "repair_targets": [13, 30, 57], "repair_candidates": [2, 36, 40, 49, 6, 21, 4, 13, 30, 57], "provenances": [{"datasetProvenance": {"datasetName": "ETHPy150Open", "filepath": "goFrendiAsgard/kokoropy/kokoropy/packages/sqlalchemy/sql/type_api.py", "license": "mit", "note": "license: bigquery_api"}}], "txt_file": "eval__VARIABLE_MISUSE__SStuB.txt-00016-of-00300", "js_count": 53860, "results": {"model": "rnn", "prob": {"loc": [[0.3166569769382477, 1.1357408766343724e-05, 1.0787583960336633e-05, 7.870627172223976e-08, 1.4611155165766831e-05, 2.1695930385590145e-08, 4.349691607785644e-06, 1.299612364391578e-07, 1.1776962338672092e-07, 4.840008386963746e-06, 6.101512894929328e-07, 4.451469948207887e-08, 9.974024806069792e-07, 7.772984389475823e-08, 1.4720977503657195e-07, 1.888931728899479e-05, 4.019029731239243e-08, 1.288131983301355e-07, 1.6546631798064482e-07, 7.5140422950426e-07, 1.035268297755465e-07, 0.04454487934708595, 2.29058684908523e-07, 4.491060110467515e-07, 0.00013543694512918591, 3.600423070793113e-08, 2.917060555773787e-06, 1.999577037281597e-08, 8.158137632108264e-08, 2.484380956957466e-06, 0.03388034552335739, 5.254648931440897e-05, 1.5011768482509069e-05, 2.166199521980161e-07, 2.0195282957047311e-07, 6.516512485177373e-07, 0.019304269924759865, 8.258724051302124e-07, 1.1811256683813554e-07, 1.698707023933821e-07, 0.00014515777002088726, 3.024725572231546e-07, 1.9230449765927915e-07, 5.848802686614363e-08, 4.449044297416549e-07, 7.372649974968226e-07, 5.8170257943857e-07, 3.858019965718995e-07, 1.1128298865514807e-05, 0.5485163331031799, 0.00047745241317898035, 1.3489250704878941e-05, 1.935755875592804e-07, 3.7678353237424744e-06, 2.3499839585383597e-07, 5.660189117406844e-08, 2.4890494387364015e-05, 0.03613854572176933]], "pointer": [[0.0, 0.0, 0.0046174065209925175, 0.0, 0.00768252182751894, 0.0, 0.0402362234890461, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.9439945220947266, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0017385340761393309, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00029369504773057997, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00029619308770634234, 0.0, 0.0, 0.0, 0.00025364907924085855, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0007586029241792858, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00012858699483331293]], "target": [0.9444167613983154]}, "loss": [3.9474289417266846, 0.057187724858522415], "acc": [0.0, 0.0, 1.0, 0.0]}, "wrong_error_location": [49]}


Trace of simplified code(s):

{"result": {"time": "2021-02-21 13:18:46.933323", "n_pass": [1, 1, 1], "n_token": 58, "loss": [0.6005383133888245, 0.057187724858522415], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "_type_map", ".", "get", "(", "type", "(", "value", ")", ",", "NULLTYPE", ")", "#NEWLINE#", "if", "(", "(", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "_type_affinity", ")", ")", ":", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"]}}
{"position": {"error_location": 49, "repair_targets": [13, 30, 57], "repair_candidates": [2, 36, 40, 49, 6, 21, 4, 13, 30, 57]}}
{"prediction": {"error_location": 0.5485163331031799, "repair_targets": [0.9439945220947266, 0.00029369504773057997, 0.00012858699483331293], "repair_candidates": [0.0046174065209925175, 0.00768252182751894, 0.0402362234890461, 0.9439945220947266, 0.0017385340761393309, 0.00029369504773057997, 0.00029619308770634234, 0.00025364907924085855, 0.0007586029241792858, 0.00012858699483331293], "target_probs": 0.9444167613983154}}


{"result": {"time": "2021-02-21 13:18:47.166588", "n_pass": [49, 4, 2], "n_token": 55, "loss": [0.5066442489624023, 0.09100335091352463], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", ")", ",", "NULLTYPE", ")", "#NEWLINE#", "if", "(", "(", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "_type_affinity", ")", ")", ":", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"]}}
{"position": {"error_location": 46, "repair_targets": [13, 27, 54], "repair_candidates": [2, 33, 37, 46, 6, 18, 4, 13, 27, 54]}}
{"prediction": {"error_location": 0.6025140881538391, "repair_targets": [0.9124737977981567, 0.0003640748327597976, 0.00017676925926934928], "repair_candidates": [0.0038025942631065845, 0.013379024341702461, 0.05261210724711418, 0.9124737977981567, 0.015829430893063545, 0.0003640748327597976, 0.0003166490059811622, 0.0003388631739653647, 0.0007067520637065172, 0.00017676925926934928], "target_probs": 0.9130146503448486}}


{"result": {"time": "2021-02-21 13:18:47.246014", "n_pass": [51, 5, 3], "n_token": 51, "loss": [0.18421195447444916, 0.04592537879943848], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "#NEWLINE#", "if", "(", "(", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "_type_affinity", ")", ")", ":", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"]}}
{"position": {"error_location": 42, "repair_targets": [13, 23, 50], "repair_candidates": [2, 29, 33, 42, 6, 18, 4, 13, 23, 50]}}
{"prediction": {"error_location": 0.831759512424469, "repair_targets": [0.9547929167747498, 0.0002328313421458006, 8.75172481755726e-05], "repair_candidates": [0.002597013721242547, 0.010458423756062984, 0.029302038252353668, 0.9547929167747498, 0.0016716178506612778, 0.0002328313421458006, 0.00023139736731536686, 0.00021036203543189913, 0.0004158441151957959, 8.75172481755726e-05], "target_probs": 0.9551132321357727}}


{"result": {"time": "2021-02-21 13:18:47.321075", "n_pass": [52, 6, 4], "n_token": 47, "loss": [0.12711943686008453, 0.022721903398633003], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "_type_affinity", ")", ")", ":", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"]}}
{"position": {"error_location": 38, "repair_targets": [13, 19, 46], "repair_candidates": [2, 25, 29, 38, 6, 18, 4, 13, 19, 46]}}
{"prediction": {"error_location": 0.8806284070014954, "repair_targets": [0.9774214029312134, 8.470007742289454e-05, 2.8184651455376297e-05], "repair_candidates": [0.000991714303381741, 0.005466419272124767, 0.015086058527231216, 0.9774214029312134, 0.0006045001209713519, 8.470007742289454e-05, 9.203195804730058e-05, 0.00013657148519996554, 8.842560782795772e-05, 2.8184651455376297e-05], "target_probs": 0.977534294128418}}


{"result": {"time": "2021-02-21 13:18:47.393818", "n_pass": [56, 7, 5], "n_token": 43, "loss": [0.02012091688811779, 0.019734414294362068], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"]}}
{"position": {"error_location": 34, "repair_targets": [13, 19, 42], "repair_candidates": [2, 25, 29, 34, 6, 18, 4, 13, 19, 42]}}
{"prediction": {"error_location": 0.9800801873207092, "repair_targets": [0.9803938865661621, 4.812052793568e-05, 1.702791814750526e-05], "repair_candidates": [0.0006337686791084707, 0.0048965634778141975, 0.013573245145380497, 0.9803938865661621, 0.000282618886558339, 4.812052793568e-05, 7.846306834835559e-05, 4.710418215836398e-05, 2.923939609900117e-05, 1.702791814750526e-05], "target_probs": 0.9804590344429016}}


{"result": {"time": "2021-02-21 13:18:47.463974", "n_pass": [58, 8, 6], "n_token": 39, "loss": [0.24101975560188293, 0.014397413469851017], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "#NEWLINE#", "#INDENT#", "return", "_coerced_type"]}}
{"position": {"error_location": 34, "repair_targets": [13, 19, 38], "repair_candidates": [2, 25, 29, 34, 6, 18, 4, 13, 19, 38]}}
{"prediction": {"error_location": 0.7858260869979858, "repair_targets": [0.9856783747673035, 2.209484955528751e-05, 5.273467650113162e-06], "repair_candidates": [0.0011194508988410234, 0.0038182283751666546, 0.009040922857820988, 0.9856783747673035, 7.02130637364462e-05, 2.209484955528751e-05, 4.990146044292487e-05, 2.735503949224949e-05, 0.00016820282326079905, 5.273467650113162e-06], "target_probs": 0.9857057332992554}}


{"result": {"time": "2021-02-21 13:18:47.602980", "n_pass": [92, 10, 7], "n_token": 37, "loss": [0.8613653182983398, 0.011486504226922989], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", ",", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 34, "repair_targets": [13, 19, 36], "repair_candidates": [2, 25, 29, 34, 6, 18, 4, 13, 19, 36]}}
{"prediction": {"error_location": 0.42258477210998535, "repair_targets": [0.9885616302490234, 1.4107159586274065e-05, 3.453611725490191e-06], "repair_candidates": [0.0007846091175451875, 0.004496198613196611, 0.00598595105111599, 0.9885616302490234, 5.038524614064954e-05, 1.4107159586274065e-05, 2.8282760467845947e-05, 1.7295204088441096e-05, 5.807453271700069e-05, 3.453611725490191e-06], "target_probs": 0.9885792136192322}}


{"result": {"time": "2021-02-21 13:18:47.811130", "n_pass": [96, 13, 8], "n_token": 36, "loss": [0.6378686428070068, 0.006612418685108423], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", "op", ",", "value", ")", ":", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 33, "repair_targets": [12, 18, 35], "repair_candidates": [2, 24, 28, 33, 5, 17, 3, 12, 18, 35]}}
{"prediction": {"error_location": 0.5284174680709839, "repair_targets": [0.9933930039405823, 1.3522535482479725e-05, 2.8732304144796217e-06], "repair_candidates": [0.0003015792462974787, 0.004777074791491032, 0.0013830374227836728, 0.9933930039405823, 4.15375798183959e-05, 1.3522535482479725e-05, 2.8938124160049483e-05, 1.586277358001098e-05, 4.26120896008797e-05, 2.8732304144796217e-06], "target_probs": 0.9934093952178955}}


{"result": {"time": "2021-02-21 13:18:47.879260", "n_pass": [99, 14, 9], "n_token": 34, "loss": [0.7722945809364319, 0.027949532493948936], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "\"Suggest a type for a 'coerced' Python value in an expression.\\n\\n        Given an operator and value, gives the type a chance\\n        to return a type which the value should be coerced into.\\n\\n        The default behavior here is conservative; if the right-hand\\n        side is already coerced into a SQL type based on its\\n        Python type, it is usually left alone.\\n\\n        End-user functionality extension here should generally be via\\n        :class:`.TypeDecorator`, which provides more liberal behavior in that\\n        it defaults to coercing the other side of the expression into this\\n        type, thus applying special Python conversions above and beyond those\\n        needed by the DBAPI to both ides. It also provides the public method\\n        :meth:`.TypeDecorator.coerce_compared_value` which is intended for\\n        end-user customization of this behavior.\\n\\n        \"", "#NEWLINE#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 31, "repair_targets": [10, 16, 33], "repair_candidates": [2, 22, 26, 31, 5, 15, 3, 10, 16, 33]}}
{"prediction": {"error_location": 0.46195188164711, "repair_targets": [0.9723830819129944, 4.7280958824558184e-05, 7.065346835588571e-06], "repair_candidates": [0.0016706588212400675, 0.017095565795898438, 0.00843205489218235, 0.9723830819129944, 0.0001290126092499122, 4.7280958824558184e-05, 9.509344818070531e-05, 3.197067053406499e-05, 0.00010811423999257386, 7.065346835588571e-06], "target_probs": 0.9724374413490295}}


{"result": {"time": "2021-02-21 13:18:48.012169", "n_pass": [101, 16, 10], "n_token": 32, "loss": [0.7166546583175659, 0.10184251517057419], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "NULLTYPE", ")", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 29, "repair_targets": [8, 14, 31], "repair_candidates": [2, 20, 24, 29, 5, 13, 3, 8, 14, 31]}}
{"prediction": {"error_location": 0.48838338255882263, "repair_targets": [0.9030786156654358, 8.113429794320837e-05, 1.2012498700642027e-05], "repair_candidates": [0.004696459509432316, 0.048433996737003326, 0.04307775944471359, 0.9030786156654358, 0.0002517142565920949, 8.113429794320837e-05, 0.00011098081449745223, 5.390523074311204e-05, 0.00020336228772066534, 1.2012498700642027e-05], "target_probs": 0.9031717777252197}}


{"result": {"time": "2021-02-21 13:18:48.144730", "n_pass": [106, 18, 11], "n_token": 30, "loss": [0.5683566331863403, 0.09942303597927094], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "or", "(", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 27, "repair_targets": [8, 14, 29], "repair_candidates": [2, 18, 22, 27, 5, 13, 3, 8, 14, 29]}}
{"prediction": {"error_location": 0.566455602645874, "repair_targets": [0.9052519798278809, 9.773172496352345e-05, 9.886928637570236e-06], "repair_candidates": [0.0017717288574203849, 0.039027679711580276, 0.05320652574300766, 0.9052519798278809, 0.0002807530399877578, 9.773172496352345e-05, 0.00020787649555131793, 2.9187311156420037e-05, 0.00011673566041281447, 9.886928637570236e-06], "target_probs": 0.9053596258163452}}


{"result": {"time": "2021-02-21 13:18:48.208249", "n_pass": [107, 19, 12], "n_token": 28, "loss": [0.3704286515712738, 0.093671053647995], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "self", ".", "_type_affinity", "is", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 25, "repair_targets": [8, 14, 27], "repair_candidates": [2, 16, 20, 25, 5, 13, 3, 8, 14, 27]}}
{"prediction": {"error_location": 0.6904383301734924, "repair_targets": [0.9104138612747192, 0.0001557505311211571, 1.2646348295675125e-05], "repair_candidates": [0.0013191180769354105, 0.034278709441423416, 0.05309748277068138, 0.9104138612747192, 0.00040476207504980266, 0.0001557505311211571, 0.00015638711920473725, 4.7022294893395156e-05, 0.00011423395335441455, 1.2646348295675125e-05], "target_probs": 0.9105822443962097}}


{"result": {"time": "2021-02-21 13:18:48.271351", "n_pass": [109, 20, 13], "n_token": 26, "loss": [0.10153647512197495, 0.08601471781730652], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "self", ".", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 23, "repair_targets": [8, 14, 25], "repair_candidates": [2, 16, 18, 23, 5, 13, 3, 8, 14, 25]}}
{"prediction": {"error_location": 0.9034481048583984, "repair_targets": [0.9172934293746948, 0.0002700264158193022, 1.7310876501142047e-05], "repair_candidates": [0.0016504502855241299, 0.030530331656336784, 0.048825014382600784, 0.9172934293746948, 0.000930569542106241, 0.0002700264158193022, 0.00023287945077754557, 9.913936082739383e-05, 0.00015098073345143348, 1.7310876501142047e-05], "target_probs": 0.9175807237625122}}


{"result": {"time": "2021-02-21 13:18:48.395816", "n_pass": [114, 22, 14], "n_token": 25, "loss": [0.3105491101741791, 0.16999419033527374], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "type", "(", "value", "_coerced_type", "is", "self", ".", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 22, "repair_targets": [7, 13, 24], "repair_candidates": [1, 15, 17, 22, 4, 12, 2, 7, 13, 24]}}
{"prediction": {"error_location": 0.7330443859100342, "repair_targets": [0.8433448076248169, 0.00030247989343479276, 2.2402229660656303e-05], "repair_candidates": [0.004534548614174128, 0.09053732454776764, 0.059146106243133545, 0.8433448076248169, 0.001092716702260077, 0.00030247989343479276, 0.00038681895239278674, 0.00013047759421169758, 0.0005024297279305756, 2.2402229660656303e-05], "target_probs": 0.8436697125434875}}


{"result": {"time": "2021-02-21 13:18:48.582623", "n_pass": [121, 25, 15], "n_token": 23, "loss": [0.7355363368988037, 0.32561686635017395], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "is", "self", ".", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 20, "repair_targets": [7, 11, 22], "repair_candidates": [1, 13, 15, 20, 4, 10, 2, 7, 11, 22]}}
{"prediction": {"error_location": 0.4792483448982239, "repair_targets": [0.7206952571868896, 0.0013375633861869574, 4.892333163297735e-05], "repair_candidates": [0.012499726377427578, 0.20084281265735626, 0.057557493448257446, 0.7206952571868896, 0.0024078369606286287, 0.0013375633861869574, 0.0020216761622577906, 0.0004673149378504604, 0.0021214340813457966, 4.892333163297735e-05], "target_probs": 0.7220817804336548}}


{"result": {"time": "2021-02-21 13:18:48.828247", "n_pass": [157, 29, 16], "n_token": 22, "loss": [0.44892048835754395, 0.41462641954421997], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", ".", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 19, "repair_targets": [7, 11, 21], "repair_candidates": [1, 12, 14, 19, 4, 10, 2, 7, 11, 21]}}
{"prediction": {"error_location": 0.638316810131073, "repair_targets": [0.6337625980377197, 0.026766277849674225, 5.809728099848144e-05], "repair_candidates": [0.012725901789963245, 0.23527082800865173, 0.0790124237537384, 0.6337625980377197, 0.00695952121168375, 0.026766277849674225, 0.0013425713405013084, 0.0014429927105084062, 0.00265878951177001, 5.809728099848144e-05], "target_probs": 0.6605870127677917}}


{"result": {"time": "2021-02-21 13:18:48.888877", "n_pass": [159, 30, 17], "n_token": 21, "loss": [0.1668156534433365, 0.25816598534584045], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", "self", ".", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 18, "repair_targets": [7, 11, 20], "repair_candidates": [1, 12, 13, 18, 4, 10, 2, 7, 11, 20]}}
{"prediction": {"error_location": 0.8463556170463562, "repair_targets": [0.7610751390457153, 0.011369265615940094, 2.2609545339946635e-05], "repair_candidates": [0.007837237790226936, 0.1782195270061493, 0.03354066237807274, 0.7610751390457153, 0.003918764181435108, 0.011369265615940094, 0.00264814798720181, 0.0004100593214388937, 0.000958637916482985, 2.2609545339946635e-05], "target_probs": 0.7724670171737671}}


{"result": {"time": "2021-02-21 13:18:48.948587", "n_pass": [161, 31, 18], "n_token": 20, "loss": [0.01297648623585701, 0.023153087124228477], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", "self", "#NEWLINE#", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 17, "repair_targets": [7, 11, 19], "repair_candidates": [1, 12, 13, 17, 4, 10, 2, 7, 11, 19]}}
{"prediction": {"error_location": 0.9871073365211487, "repair_targets": [0.9761947989463806, 0.0009161921334452927, 1.8970030168929952e-06], "repair_candidates": [0.00024540035519748926, 0.004810893442481756, 0.015965772792696953, 0.9761947989463806, 0.0015073471004143357, 0.0009161921334452927, 0.0002252100530313328, 0.00012427284673321992, 8.054235877352767e-06, 1.8970030168929952e-06], "target_probs": 0.977112889289856}}


{"result": {"time": "2021-02-21 13:18:49.008551", "n_pass": [162, 32, 19], "n_token": 19, "loss": [0.018305061385035515, 0.18598653376102448], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", "self", "#INDENT#", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 16, "repair_targets": [7, 11, 18], "repair_candidates": [1, 12, 13, 16, 4, 10, 2, 7, 11, 18]}}
{"prediction": {"error_location": 0.9818614721298218, "repair_targets": [0.8271684646606445, 0.003098094370216131, 1.826140214689076e-05], "repair_candidates": [0.0039011305198073387, 0.09176433831453323, 0.06847245991230011, 0.8271684646606445, 0.004376348108053207, 0.003098094370216131, 0.00020473198674153537, 0.0009400747367180884, 5.617413989966735e-05, 1.826140214689076e-05], "target_probs": 0.8302847743034363}}


{"result": {"time": "2021-02-21 13:18:49.067625", "n_pass": [163, 33, 20], "n_token": 18, "loss": [0.02486167848110199, 0.38854753971099854], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", "self", "return", "self", "return", "_coerced_type"]}}
{"position": {"error_location": 15, "repair_targets": [7, 11, 17], "repair_candidates": [1, 12, 13, 15, 4, 10, 2, 7, 11, 17]}}
{"prediction": {"error_location": 0.9754447340965271, "repair_targets": [0.6760075688362122, 0.0020042613614350557, 2.916447374445852e-05], "repair_candidates": [0.006593541707843542, 0.24619047343730927, 0.06143954023718834, 0.6760075688362122, 0.007399226538836956, 0.0020042613614350557, 9.333556954516098e-05, 0.00022025829821359366, 2.2662856281385757e-05, 2.916447374445852e-05], "target_probs": 0.6780409812927246}}


{"result": {"time": "2021-02-21 13:18:49.186940", "n_pass": [166, 35, 21], "n_token": 17, "loss": [0.004294221755117178, 0.5931530594825745], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "#INDENT#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", "self", "return", "self", "_coerced_type"]}}
{"position": {"error_location": 15, "repair_targets": [7, 11, 16], "repair_candidates": [1, 12, 13, 15, 4, 10, 2, 7, 11, 16]}}
{"prediction": {"error_location": 0.9957150816917419, "repair_targets": [0.5511077642440796, 0.0014456865610554814, 2.8731226848321967e-05], "repair_candidates": [0.0052994959987699986, 0.33144479990005493, 0.09783363342285156, 0.5511077642440796, 0.012709691189229488, 0.0014456865610554814, 6.648940325248986e-05, 4.623748827725649e-05, 1.7461272364016622e-05, 2.8731226848321967e-05], "target_probs": 0.5525822043418884}}


{"result": {"time": "2021-02-21 13:18:49.418582", "n_pass": [174, 39, 22], "n_token": 16, "loss": [0.001149827498011291, 0.457222580909729], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "_coerced_type", "=", "(", "value", "_coerced_type", "self", "self", "return", "self", "_coerced_type"]}}
{"position": {"error_location": 14, "repair_targets": [6, 10, 15], "repair_candidates": [1, 11, 12, 14, 4, 9, 2, 6, 10, 15]}}
{"prediction": {"error_location": 0.9988508224487305, "repair_targets": [0.6322219371795654, 0.0008056682418100536, 1.1824302418972366e-05], "repair_candidates": [0.0006002963637001812, 0.04656130075454712, 0.31244704127311707, 0.6322219371795654, 0.007288998458534479, 0.0008056682418100536, 3.516794822644442e-05, 2.046176086878404e-05, 7.31667068976094e-06, 1.1824302418972366e-05], "target_probs": 0.6330394148826599}}


{"result": {"time": "2021-02-21 13:18:49.535175", "n_pass": [177, 41, 23], "n_token": 15, "loss": [0.0033704398665577173, 0.09402982890605927], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["def coerce_compared_value(", "self", "op", ",", "value", "#NEWLINE#", "_coerced_type", "=", "value", "_coerced_type", "self", "self", "return", "self", "_coerced_type"]}}
{"position": {"error_location": 13, "repair_targets": [6, 9, 14], "repair_candidates": [1, 10, 11, 13, 4, 8, 2, 6, 9, 14]}}
{"prediction": {"error_location": 0.9966352581977844, "repair_targets": [0.9095398783683777, 0.0007113027386367321, 4.4574208004632965e-06], "repair_candidates": [0.0008938947576098144, 0.03754448890686035, 0.04598844796419144, 0.9095398783683777, 0.005259380675852299, 0.0007113027386367321, 3.556584852049127e-05, 1.789801535778679e-05, 4.578897460305598e-06, 4.4574208004632965e-06], "target_probs": 0.9102556109428406}}


{"result": {"time": "2021-02-21 13:18:49.648928", "n_pass": [185, 43, 24], "n_token": 14, "loss": [0.03628014028072357, 0.22905167937278748], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["self", "op", ",", "value", "#NEWLINE#", "_coerced_type", "=", "value", "_coerced_type", "self", "self", "return", "self", "_coerced_type"]}}
{"position": {"error_location": 12, "repair_targets": [5, 8, 13], "repair_candidates": [0, 9, 10, 12, 3, 7, 1, 5, 8, 13]}}
{"prediction": {"error_location": 0.96437007188797, "repair_targets": [0.7945366501808167, 0.0007482835208065808, 2.48046626438736e-06], "repair_candidates": [0.0022964326199144125, 0.019184881821274757, 0.1745140254497528, 0.7945366501808167, 0.008649236522614956, 0.0007482835208065808, 3.896670386893675e-05, 2.6005714971688576e-05, 3.1146366836765083e-06, 2.48046626438736e-06], "target_probs": 0.7952874302864075}}


{"result": {"time": "2021-02-21 13:18:49.705175", "n_pass": [188, 44, 25], "n_token": 13, "loss": [0.037874311208724976, 0.5833380222320557], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["self", "op", "value", "#NEWLINE#", "_coerced_type", "=", "value", "_coerced_type", "self", "self", "return", "self", "_coerced_type"]}}
{"position": {"error_location": 11, "repair_targets": [4, 7, 12], "repair_candidates": [0, 8, 9, 11, 2, 6, 1, 4, 7, 12]}}
{"prediction": {"error_location": 0.9628339409828186, "repair_targets": [0.5573657155036926, 0.0006635960889980197, 3.1892475362838013e-06], "repair_candidates": [0.004936516750603914, 0.06315771490335464, 0.36699697375297546, 0.5573657155036926, 0.006826385855674744, 0.0006635960889980197, 2.743280856520869e-05, 1.9129392967442982e-05, 3.321185886306921e-06, 3.1892475362838013e-06], "target_probs": 0.5580325126647949}}


{"result": {"time": "2021-02-21 13:18:49.816025", "n_pass": [192, 46, 26], "n_token": 12, "loss": [0.014952722936868668, 0.6275410056114197], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["self", "op", "value", "#NEWLINE#", "_coerced_type", "value", "_coerced_type", "self", "self", "return", "self", "_coerced_type"]}}
{"position": {"error_location": 10, "repair_targets": [4, 6, 11], "repair_candidates": [0, 7, 8, 10, 2, 5, 1, 4, 6, 11]}}
{"prediction": {"error_location": 0.9851585030555725, "repair_targets": [0.5311689376831055, 0.0027306440751999617, 3.4637646422197577e-06], "repair_candidates": [0.006044059991836548, 0.07527102530002594, 0.28950759768486023, 0.5311689376831055, 0.09522362798452377, 0.0027306440751999617, 3.1968378607416525e-05, 1.5876497855060734e-05, 2.802288236125605e-06, 3.4637646422197577e-06], "target_probs": 0.5339030623435974}}


{"result": {"time": "2021-02-21 13:18:49.874138", "n_pass": [197, 47, 27], "n_token": 11, "loss": [0.203598290681839, 0.4899672269821167], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["self", "op", "value", "#NEWLINE#", "_coerced_type", "value", "_coerced_type", "self", "self", "self", "_coerced_type"]}}
{"position": {"error_location": 9, "repair_targets": [4, 6, 10], "repair_candidates": [0, 7, 8, 9, 2, 5, 1, 4, 6, 10]}}
{"prediction": {"error_location": 0.8157899975776672, "repair_targets": [0.6104752421379089, 0.002159448340535164, 1.174416047433624e-05], "repair_candidates": [0.008730724453926086, 0.06719302386045456, 0.21144679188728333, 0.6104752421379089, 0.0998205840587616, 0.002159448340535164, 5.191688978811726e-05, 9.918273281073198e-05, 1.1273426025582012e-05, 1.174416047433624e-05], "target_probs": 0.6126464605331421}}




Minimal simplified tokens:

['self', 'op', 'value', '#NEWLINE#', '_coerced_type', 'value', '_coerced_type', 'self', 'self', 'self', '_coerced_type']
