
Original sample:

{"has_bug": true, "bug_kind": 1, "bug_kind_name": "VARIABLE_MISUSE", "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "#NEWLINE#", "#INDENT#", "if", "(", "counter", "==", "index", ")", ":", "#NEWLINE#", "#INDENT#", "return", "track", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "if", "(", "counter", ">", "counter", ")", ":", "#NEWLINE#", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"], "error_location": [62], "repair_targets": [4, 45], "repair_candidates": [4, 45, 11, 43, 60, 62, 101, 2, 25, 85, 15, 51, 72, 93], "provenances": [{"datasetProvenance": {"datasetName": "ETHPy150Open", "filepath": "tooxie/shiva-server/shiva/models.py", "license": "mit", "note": "license: bigquery_api"}}], "txt_file": "eval__VARIABLE_MISUSE__SStuB.txt-00018-of-00300", "js_count": 58442, "results": {"model": "rnn", "prob": {"loc": [[0.052199020981788635, 1.4066290354719513e-08, 2.9234918486054084e-08, 3.2084139789390065e-09, 4.699763067606e-08, 2.3850639241373983e-09, 2.53272069983268e-09, 8.39465243984705e-08, 2.747859539908859e-08, 9.77522773837336e-09, 7.939586765814965e-08, 1.6752181863921578e-08, 3.88011756058404e-08, 3.441178932916955e-06, 7.707399873879694e-08, 2.79236740396982e-08, 3.562312889116015e-09, 1.0604839673078459e-08, 1.4863369202089416e-08, 3.9296910614439184e-08, 1.2885249311977987e-08, 2.796119424886001e-08, 3.0034222220365336e-08, 2.8918914267705986e-06, 1.1803692245848652e-07, 0.22822916507720947, 3.886620802973084e-08, 1.280782697676841e-07, 3.1853530924053075e-09, 1.0746190604038475e-08, 1.7375040295419808e-09, 2.5696001770825205e-08, 2.530118115018354e-09, 5.663945756850808e-09, 1.0957832330404926e-07, 9.163402836520618e-08, 2.859738685856428e-07, 2.0112391041493538e-07, 5.074236142377231e-08, 1.2186316666884522e-07, 5.29754004219285e-07, 1.446742103894394e-08, 1.0294088070850194e-07, 0.007211855612695217, 5.476173328133882e-07, 0.004029199481010437, 6.101092964172494e-08, 2.161114842635925e-08, 4.1281897011913316e-08, 3.4755467392955097e-09, 3.968092187278671e-06, 0.013115906156599522, 6.479866954123281e-08, 1.5221859939629212e-05, 4.8551775932992314e-08, 2.337963906029472e-06, 3.1137108180701034e-07, 4.3895539647564874e-07, 2.1515235815172673e-08, 1.6225158105953597e-07, 0.008409594185650349, 9.424761771015255e-08, 0.005201662890613079, 5.825302551443201e-08, 2.232447648964353e-08, 9.46782350297326e-08, 1.2288929873705001e-08, 2.3051748030411545e-06, 7.610130978719098e-07, 9.994541727564865e-08, 1.0981600695458837e-07, 9.986958104946098e-08, 1.8545701863104114e-08, 3.815452398470143e-09, 3.2994069698588646e-08, 4.098447803357885e-08, 8.336866841318624e-08, 1.867594079385526e-08, 2.5793424285325273e-08, 9.499047770589186e-09, 1.5392156171856186e-07, 3.9826525608077645e-05, 3.35743060020377e-08, 6.834858368165442e-07, 8.324528977254886e-08, 0.6814143657684326, 2.8665155582530133e-07, 3.4455524544618754e-10, 6.386406425917812e-08, 4.0647915739100426e-05, 1.127840292269866e-07, 2.5539171133459604e-07, 1.0293748076151132e-08, 6.677325291093439e-05, 9.944213452683925e-09, 8.789540650866456e-09, 1.3559133549279068e-07, 4.330621639070387e-09, 3.891004851652724e-08, 1.091460603674932e-06, 8.619499425321919e-08, 2.2777678054808348e-07, 1.3127970532877953e-07, 2.620733766889316e-06]], "pointer": [[0.0, 0.0, 0.00017947659944184124, 0.0, 0.5183985829353333, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.23163945972919464, 0.0, 0.0, 0.0, 0.2368725687265396, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0010574569460004568, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0010435180738568306, 0.0, 0.0005227190558798611, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0007770521915517747, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0041976748034358025, 0.0, 0.001735326717607677, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0009597313473932445, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0009636038448661566, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0009429203346371651, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0007099520298652351, 0.0, 0.0]], "target": [0.5189213156700134]}, "loss": [5.258776664733887, 0.6560029983520508], "acc": [0.0, 0.0, 1.0, 0.0]}, "wrong_error_location": [85]}


Trace of simplified code(s):

{"result": {"time": "2021-02-21 13:30:53.906156", "n_pass": [1, 1, 1], "n_token": 104, "loss": [0.3835846185684204, 0.6560029983520508], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "#NEWLINE#", "#INDENT#", "if", "(", "counter", "==", "index", ")", ":", "#NEWLINE#", "#INDENT#", "return", "track", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "if", "(", "counter", ">", "counter", ")", ":", "#NEWLINE#", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 85, "repair_targets": [4, 45], "repair_candidates": [4, 45, 11, 43, 60, 62, 101, 2, 25, 85, 15, 51, 72, 93]}}
{"prediction": {"error_location": 0.6814143657684326, "repair_targets": [0.5183985829353333, 0.0005227190558798611], "repair_candidates": [0.00017947659944184124, 0.5183985829353333, 0.23163945972919464, 0.2368725687265396, 0.0010574569460004568, 0.0010435180738568306, 0.0005227190558798611, 0.0007770521915517747, 0.0041976748034358025, 0.001735326717607677, 0.0009597313473932445, 0.0009636038448661566, 0.0009429203346371651, 0.0007099520298652351], "target_probs": 0.5189213156700134}}


{"result": {"time": "2021-02-21 13:30:55.344097", "n_pass": [105, 15, 2], "n_token": 101, "loss": [0.41483747959136963, 0.6462947726249695], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "#NEWLINE#", "#INDENT#", "return", "track", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "if", "(", "counter", ">", "counter", ")", ":", "#NEWLINE#", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 82, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 57, 59, 98, 2, 25, 82, 15, 48, 69, 90]}}
{"prediction": {"error_location": 0.6604475975036621, "repair_targets": [0.5236560702323914, 0.0003275969938840717], "repair_candidates": [0.00018555534188635647, 0.5236560702323914, 0.2439754456281662, 0.22164440155029297, 0.0012397839454934, 0.00045369527651928365, 0.0003275969938840717, 0.00037608787533827126, 0.0028934578876942396, 0.0013880175538361073, 0.0011033514747396111, 0.001133048441261053, 0.0008900699904188514, 0.0007333797984756529], "target_probs": 0.5239836573600769}}


{"result": {"time": "2021-02-21 13:30:55.446785", "n_pass": [108, 16, 3], "n_token": 98, "loss": [0.5428457856178284, 0.5926735997200012], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "else", ":", "#NEWLINE#", "#INDENT#", "if", "(", "counter", ">", "counter", ")", ":", "#NEWLINE#", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 79, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 54, 56, 95, 2, 25, 79, 15, 45, 66, 87]}}
{"prediction": {"error_location": 0.5810922384262085, "repair_targets": [0.5515896677970886, 0.001257522264495492], "repair_candidates": [0.00012237572809681296, 0.5515896677970886, 0.2866346538066864, 0.15068094432353973, 0.0010295241372659802, 0.0006478549330495298, 0.001257522264495492, 0.00013234179641585797, 0.0023916412610560656, 0.0012566375080496073, 0.0009747292497195303, 0.0015774305211380124, 0.0008822798845358193, 0.0008223996846936643], "target_probs": 0.5528472065925598}}


{"result": {"time": "2021-02-21 13:30:55.549550", "n_pass": [110, 17, 4], "n_token": 95, "loss": [0.5858411192893982, 0.598212480545044], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "#INDENT#", "if", "(", "counter", ">", "counter", ")", ":", "#NEWLINE#", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 76, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 51, 53, 92, 2, 25, 76, 15, 45, 63, 84]}}
{"prediction": {"error_location": 0.5566374063491821, "repair_targets": [0.548931360244751, 0.0008621882880106568], "repair_candidates": [0.00016927343676798046, 0.548931360244751, 0.29589763283729553, 0.14441902935504913, 0.0014029709855094552, 0.00033519399585202336, 0.0008621882880106568, 0.00010718819976318628, 0.001051604631356895, 0.0014599040150642395, 0.0011507926974445581, 0.0018702211091294885, 0.0011996320681646466, 0.0011429418809711933], "target_probs": 0.549793541431427}}


{"result": {"time": "2021-02-21 13:30:55.647913", "n_pass": [111, 18, 5], "n_token": 92, "loss": [0.36402076482772827, 0.5713581442832947], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", ")", ":", "#NEWLINE#", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 73, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 48, 50, 89, 2, 25, 73, 15, 45, 60, 81]}}
{"prediction": {"error_location": 0.6948768496513367, "repair_targets": [0.5642162561416626, 0.0005416395142674446], "repair_candidates": [0.00014904026465956122, 0.5642162561416626, 0.30631959438323975, 0.06758436560630798, 0.0016238705720752478, 0.000461585441371426, 0.0005416395142674446, 6.910396768944338e-05, 0.05289522558450699, 0.0019490052945911884, 0.0009870670037344098, 0.0008695700671523809, 0.0006786053418181837, 0.0016550302971154451], "target_probs": 0.5647578835487366}}


{"result": {"time": "2021-02-21 13:30:55.745239", "n_pass": [113, 19, 6], "n_token": 89, "loss": [0.2803928852081299, 0.5862447619438171], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#INDENT#", "return", "None", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 70, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 48, 50, 86, 2, 25, 70, 15, 45, 57, 78]}}
{"prediction": {"error_location": 0.7554870843887329, "repair_targets": [0.5558789372444153, 0.000533875310793519], "repair_candidates": [0.0001332694519078359, 0.5558789372444153, 0.31067365407943726, 0.10759881138801575, 0.0011476397048681974, 0.00041337942820973694, 0.000533875310793519, 5.926477024331689e-05, 0.01968665048480034, 0.0010501090437173843, 0.0005053456407040358, 0.0003776313387788832, 0.0005674240528605878, 0.001373983803205192], "target_probs": 0.5564128160476685}}


{"result": {"time": "2021-02-21 13:30:55.840517", "n_pass": [114, 20, 7], "n_token": 86, "loss": [0.3752416968345642, 0.5190787315368652], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter", "(", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 67, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 48, 50, 83, 2, 25, 67, 15, 45, 54, 75]}}
{"prediction": {"error_location": 0.68712317943573, "repair_targets": [0.5944827198982239, 0.0005858083604834974], "repair_candidates": [0.0001671955396886915, 0.5944827198982239, 0.28543978929519653, 0.10774558037519455, 0.0015138069866225123, 0.0004159288655500859, 0.0005858083604834974, 7.069283310556784e-05, 0.005462761037051678, 0.0003133628342766315, 0.00034398536081425846, 0.0009060563752427697, 0.0009039819706231356, 0.0016484485240653157], "target_probs": 0.5950685143470764}}


{"result": {"time": "2021-02-21 13:30:56.031359", "n_pass": [117, 22, 8], "n_token": 82, "loss": [0.7256709337234497, 0.5061008930206299], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "(", "TrackPlaylistRelationship", ".", "playlist", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 63, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 48, 50, 79, 2, 25, 63, 15, 45, 54, 71]}}
{"prediction": {"error_location": 0.48399972915649414, "repair_targets": [0.6024249792098999, 0.00041655893437564373], "repair_candidates": [0.00014958255633246154, 0.6024249792098999, 0.28469231724739075, 0.10501955449581146, 0.0010706803295761347, 0.0002860419626813382, 0.00041655893437564373, 5.5485539633082226e-05, 0.003172952216118574, 0.00020369695266708732, 0.00032610647031106055, 0.000553244142793119, 0.00036374846240505576, 0.001265037222765386], "target_probs": 0.6028415560722351}}


{"result": {"time": "2021-02-21 13:30:56.123223", "n_pass": [118, 23, 9], "n_token": 78, "loss": [0.32431384921073914, 0.5280883312225342], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "(", "TrackPlaylistRelationship", ".", "previous_track", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 59, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 48, 50, 75, 2, 25, 59, 15, 45, 54, 67]}}
{"prediction": {"error_location": 0.7230232357978821, "repair_targets": [0.5891746282577515, 0.0005566313047893345], "repair_candidates": [0.00017753631982486695, 0.5891746282577515, 0.2875937223434448, 0.10204260051250458, 0.0018200440099462867, 0.0005280858604237437, 0.0005566313047893345, 6.537178705912083e-05, 0.009965546429157257, 0.0004133293405175209, 0.0002374922769377008, 0.000817095919046551, 0.003704309230670333, 0.0029036439955234528], "target_probs": 0.5897312760353088}}


{"result": {"time": "2021-02-21 13:30:56.213096", "n_pass": [120, 24, 10], "n_token": 74, "loss": [0.47749626636505127, 0.47621211409568787], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", ".", "query", ".", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 59, "repair_targets": [4, 42], "repair_candidates": [4, 42, 11, 40, 48, 50, 71, 2, 25, 59, 15, 45, 54, 63]}}
{"prediction": {"error_location": 0.6203346252441406, "repair_targets": [0.6204162836074829, 0.0007154413033276796], "repair_candidates": [0.00023411471920553595, 0.6204162836074829, 0.2524285614490509, 0.10776031762361526, 0.0025786918122321367, 0.0004991638124920428, 0.0007154413033276796, 8.83717875694856e-05, 0.00746185565367341, 0.00027543422766029835, 0.0008498134557157755, 0.0012007433688268065, 0.0003229541762266308, 0.005168183706700802], "target_probs": 0.6211317181587219}}


{"result": {"time": "2021-02-21 13:30:56.567033", "n_pass": [130, 28, 11], "n_token": 71, "loss": [0.22013898193836212, 0.5936821699142456], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", "filter_by", "(", "playlist", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 56, "repair_targets": [4, 39], "repair_candidates": [4, 39, 11, 37, 45, 47, 68, 2, 22, 56, 15, 42, 51, 60]}}
{"prediction": {"error_location": 0.8024072647094727, "repair_targets": [0.55157071352005, 0.0007191741606220603], "repair_candidates": [0.00029833498410880566, 0.55157071352005, 0.21894291043281555, 0.2047126591205597, 0.004506644327193499, 0.0005716279265470803, 0.0007191741606220603, 0.00010354818368796259, 0.0072317966260015965, 0.0002907447633333504, 0.00306291994638741, 0.0018437880789861083, 0.00044202111894264817, 0.005703154020011425], "target_probs": 0.5522899031639099}}


{"result": {"time": "2021-02-21 13:30:56.653549", "n_pass": [131, 29, 12], "n_token": 68, "loss": [0.7334765791893005, 0.6541628837585449], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", ".", "first", "(", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 53, "repair_targets": [4, 36], "repair_candidates": [4, 36, 11, 34, 42, 44, 65, 2, 19, 53, 15, 39, 48, 57]}}
{"prediction": {"error_location": 0.4802365005016327, "repair_targets": [0.5187393426895142, 0.0011377062182873487], "repair_candidates": [0.00030682800570502877, 0.5187393426895142, 0.2864992618560791, 0.18234585225582123, 0.005997647065669298, 0.0006676726043224335, 0.0011377062182873487, 0.00012117056758143008, 0.0011098779505118728, 0.00018338239169679582, 0.000322014995617792, 0.0004947277484461665, 0.00025483386707492173, 0.0018197421450167894], "target_probs": 0.5198770761489868}}


{"result": {"time": "2021-02-21 13:30:57.164657", "n_pass": [145, 35, 13], "n_token": 64, "loss": [0.16190585494041443, 0.5833680629730225], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "=", "0", "#NEWLINE#", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 53, "repair_targets": [4, 36], "repair_candidates": [4, 36, 11, 34, 42, 44, 61, 2, 19, 53, 15, 39, 48, 57]}}
{"prediction": {"error_location": 0.8505213856697083, "repair_targets": [0.5553818345069885, 0.0026339555624872446], "repair_candidates": [0.0003678206412587315, 0.5553818345069885, 0.26729267835617065, 0.11057359725236893, 0.01541487779468298, 0.0015856381505727768, 0.0026339555624872446, 0.00017570036288816482, 0.04430019482970238, 0.0007511380244977772, 0.00024368376762140542, 0.00025636909413151443, 5.965893069515005e-05, 0.0009628550615161657], "target_probs": 0.558015763759613}}


{"result": {"time": "2021-02-21 13:30:57.333873", "n_pass": [151, 37, 14], "n_token": 61, "loss": [0.8269990086555481, 0.5077748894691467], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "while", "True", ":", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 50, "repair_targets": [4, 33], "repair_candidates": [4, 33, 11, 31, 39, 41, 58, 2, 16, 50, 12, 36, 45, 54]}}
{"prediction": {"error_location": 0.43735983967781067, "repair_targets": [0.5959125757217407, 0.005920650437474251], "repair_candidates": [0.0003685132833197713, 0.5959125757217407, 0.0838719978928566, 0.2814410328865051, 0.009127835743129253, 0.0027337493374943733, 0.005920650437474251, 0.00025703321443870664, 0.017625609412789345, 0.0015108005609363317, 0.0001377058360958472, 0.00021785226999782026, 6.296941865002736e-05, 0.0008116893004626036], "target_probs": 0.6018332242965698}}


{"result": {"time": "2021-02-21 13:30:57.658229", "n_pass": [157, 41, 15], "n_token": 58, "loss": [0.6287608742713928, 0.6810803413391113], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", ")", "#NEWLINE#", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 47, "repair_targets": [4, 30], "repair_candidates": [4, 30, 11, 28, 36, 38, 55, 2, 16, 47, 12, 33, 42, 51]}}
{"prediction": {"error_location": 0.5332521796226501, "repair_targets": [0.482975035905838, 0.023094896227121353], "repair_candidates": [0.0005529900081455708, 0.482975035905838, 0.0756041407585144, 0.32882970571517944, 0.009507576003670692, 0.05237414687871933, 0.023094896227121353, 0.0002706573868636042, 0.02421499416232109, 0.0013588174479082227, 0.00011349918349878863, 0.00010346830822527409, 4.4316260755294934e-05, 0.0009557284065522254], "target_probs": 0.5060699582099915}}


{"result": {"time": "2021-02-21 13:30:58.061773", "n_pass": [175, 46, 16], "n_token": 55, "loss": [0.7899529933929443, 0.4193808138370514], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", ")", ",", "==", "track", ")", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 44, "repair_targets": [4, 27], "repair_candidates": [4, 27, 11, 25, 33, 35, 52, 2, 16, 44, 12, 30, 39, 48]}}
{"prediction": {"error_location": 0.45386624336242676, "repair_targets": [0.6560843586921692, 0.0013694230001419783], "repair_candidates": [0.0011400432558730245, 0.6560843586921692, 0.07636088132858276, 0.2309895008802414, 0.009892378933727741, 0.0012182323262095451, 0.0013694230001419783, 0.0001487896661274135, 0.02032151073217392, 0.0007240216946229339, 0.00017196073895320296, 0.00041169702308252454, 7.646227459190413e-05, 0.001090745092369616], "target_probs": 0.6574537754058838}}


{"result": {"time": "2021-02-21 13:30:58.928706", "n_pass": [240, 57, 17], "n_token": 53, "loss": [0.5881316065788269, 0.4741893708705902], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", "==", "track", ")", ")", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 44, "repair_targets": [4, 27], "repair_candidates": [4, 27, 11, 25, 33, 35, 50, 2, 16, 44, 12, 30, 39, 46]}}
{"prediction": {"error_location": 0.5553639531135559, "repair_targets": [0.621008038520813, 0.0013813389232382178], "repair_candidates": [0.0012626075185835361, 0.621008038520813, 0.09951990097761154, 0.2182716578245163, 0.009888497181236744, 0.0011473745107650757, 0.0013813389232382178, 0.00015085420454852283, 0.04493538662791252, 0.0010530311847105622, 0.00024639099137857556, 0.00029684751643799245, 1.8917089619208127e-05, 0.00081919867079705], "target_probs": 0.6223893761634827}}


{"result": {"time": "2021-02-21 13:30:59.006902", "n_pass": [242, 58, 18], "n_token": 51, "loss": [0.8450777530670166, 0.5674545764923096], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", "==", "track", "#NEWLINE#", "counter", "+=", "1"]}}
{"position": {"error_location": 44, "repair_targets": [4, 27], "repair_candidates": [4, 27, 11, 25, 33, 35, 48, 2, 16, 44, 12, 30, 39, 46]}}
{"prediction": {"error_location": 0.4295240044593811, "repair_targets": [0.566070020198822, 0.0008967804606072605], "repair_candidates": [0.0011477242223918438, 0.566070020198822, 0.09445969760417938, 0.26053011417388916, 0.012181434780359268, 0.0008174484828487039, 0.0008967804606072605, 0.00016721342399250716, 0.06114095449447632, 0.0008728598477318883, 0.00037204104592092335, 0.00042087954352609813, 3.3779022487578914e-05, 0.0008890422177501023], "target_probs": 0.5669667720794678}}


{"result": {"time": "2021-02-21 13:30:59.084091", "n_pass": [244, 59, 19], "n_token": 49, "loss": [0.9432121515274048, 0.6800798773765564], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "def get_track_at(", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 44, "repair_targets": [4, 27], "repair_candidates": [4, 27, 11, 25, 33, 35, 48, 2, 16, 44, 12, 30, 39, 46]}}
{"prediction": {"error_location": 0.38937512040138245, "repair_targets": [0.5058566927909851, 0.0007198444218374789], "repair_candidates": [0.0009917736751958728, 0.5058566927909851, 0.09964540600776672, 0.31349483132362366, 0.015449533239006996, 0.0006569530232809484, 0.0007198444218374789, 0.00015103415353223681, 0.061085935682058334, 0.0008640278829261661, 0.0002830500015988946, 0.0003577708266675472, 4.152405381319113e-05, 0.0004016009334009141], "target_probs": 0.5065765380859375}}


{"result": {"time": "2021-02-21 13:30:59.237063", "n_pass": [246, 61, 20], "n_token": 48, "loss": [0.8247446417808533, 0.6657888889312744], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "\"\\n        This method finds the track at position `index` in the current\\n        playlist. Will return None if the track is not present.\\n\\n        It fetches the playlist's parent (the track with `previous_track_pk`\\n        None) and queries for each susequent item until the requested item is\\n        found.  This implementation is the slowest, but for now is ok because\\n        is also the simplest.\\n\\n        This is a very good candidate for optimization.\\n        \"", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 43, "repair_targets": [3, 26], "repair_candidates": [3, 26, 10, 24, 32, 34, 47, 1, 15, 43, 11, 29, 38, 45]}}
{"prediction": {"error_location": 0.4383469521999359, "repair_targets": [0.5134647488594055, 0.00040319663821719587], "repair_candidates": [0.006730042397975922, 0.5134647488594055, 0.09120107442140579, 0.2812833786010742, 0.016989124938845634, 0.00046156326425261796, 0.00040319663821719587, 9.100958413910121e-05, 0.08777503669261932, 0.0006207477999851108, 0.00022402324248105288, 0.00046698737423866987, 3.052523607038893e-05, 0.0002585244656074792], "target_probs": 0.513867974281311}}


{"result": {"time": "2021-02-21 13:30:59.694508", "n_pass": [254, 67, 21], "n_token": 47, "loss": [0.7477927207946777, 0.5439472198486328], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 42, "repair_targets": [3, 25], "repair_candidates": [3, 25, 9, 23, 31, 33, 46, 1, 14, 42, 10, 28, 37, 44]}}
{"prediction": {"error_location": 0.47341033816337585, "repair_targets": [0.5800392627716064, 0.0004133240145165473], "repair_candidates": [0.00461973249912262, 0.5800392627716064, 0.12238622456789017, 0.21367952227592468, 0.010550810024142265, 0.0005019689560867846, 0.0004133240145165473, 9.928947110893205e-05, 0.0662524625658989, 0.0006132517592050135, 0.0001904063974507153, 0.0003434077661950141, 3.098133311141282e-05, 0.0002793281164485961], "target_probs": 0.580452561378479}}


{"result": {"time": "2021-02-21 13:30:59.769529", "n_pass": [255, 68, 22], "n_token": 46, "loss": [0.4984246492385864, 0.5076417922973633], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "TrackPlaylistRelationship", ".", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 41, "repair_targets": [3, 24], "repair_candidates": [3, 24, 8, 22, 30, 32, 45, 1, 13, 41, 9, 27, 36, 43]}}
{"prediction": {"error_location": 0.6074868440628052, "repair_targets": [0.6015101075172424, 0.0004032286233268678], "repair_candidates": [0.005128743592649698, 0.6015101075172424, 0.057949356734752655, 0.2431265413761139, 0.014620669186115265, 0.0005480494583025575, 0.0004032286233268678, 9.12253963178955e-05, 0.0752970278263092, 0.0005792166921310127, 0.00011017838551197201, 0.00039960406138561666, 2.8729718906106427e-05, 0.0002072938805213198], "target_probs": 0.601913332939148}}


{"result": {"time": "2021-02-21 13:31:00.357911", "n_pass": [272, 76, 23], "n_token": 44, "loss": [0.5716981291770935, 0.6784730553627014], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "#INDENT#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 39, "repair_targets": [3, 24], "repair_candidates": [3, 24, 8, 22, 30, 32, 43, 1, 13, 39, 9, 27, 36, 41]}}
{"prediction": {"error_location": 0.564565896987915, "repair_targets": [0.5069711208343506, 0.00042006358853541315], "repair_candidates": [0.0051550730131566525, 0.5069711208343506, 0.060397837311029434, 0.12737968564033508, 0.023447146639227867, 0.0006813689833506942, 0.00042006358853541315, 5.9950380091322586e-05, 0.27375316619873047, 0.0010622289264574647, 0.00047216113307513297, 7.459023618139327e-05, 1.0234160072286613e-05, 0.00011535797239048406], "target_probs": 0.5073911547660828}}


{"result": {"time": "2021-02-21 13:31:00.795766", "n_pass": [283, 82, 24], "n_token": 43, "loss": [0.8023563623428345, 0.5794504880905151], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "=", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 38, "repair_targets": [3, 23], "repair_candidates": [3, 23, 7, 21, 29, 31, 42, 1, 12, 38, 8, 26, 35, 40]}}
{"prediction": {"error_location": 0.44827142357826233, "repair_targets": [0.5595704913139343, 0.0006356405792757869], "repair_candidates": [0.004492796491831541, 0.5595704913139343, 0.0644664317369461, 0.13703951239585876, 0.020692216232419014, 0.0010559597285464406, 0.0006356405792757869, 8.757934119785205e-05, 0.20997773110866547, 0.001244208193384111, 0.0004694412637036294, 9.169662371277809e-05, 1.3689369552594144e-05, 0.00016258630785159767], "target_probs": 0.5602061152458191}}


{"result": {"time": "2021-02-21 13:31:01.952667", "n_pass": [348, 98, 25], "n_token": 42, "loss": [0.788843035697937, 0.6360549330711365], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ")", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 37, "repair_targets": [3, 22], "repair_candidates": [3, 22, 7, 20, 28, 30, 41, 1, 12, 37, 8, 25, 34, 39]}}
{"prediction": {"error_location": 0.4543702006340027, "repair_targets": [0.5281649827957153, 0.0012117859441787004], "repair_candidates": [0.005141788627952337, 0.5281649827957153, 0.0893520936369896, 0.13654565811157227, 0.004862953443080187, 0.0015933335525915027, 0.0012117859441787004, 0.0001044127275235951, 0.2307249754667282, 0.0017145811580121517, 0.00032301797182299197, 9.764484275365248e-05, 1.3727039004152175e-05, 0.00014904105046298355], "target_probs": 0.529376745223999}}


{"result": {"time": "2021-02-21 13:31:02.027671", "n_pass": [349, 99, 26], "n_token": 41, "loss": [0.8582205772399902, 0.41190293431282043], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "first", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 36, "repair_targets": [3, 21], "repair_candidates": [3, 21, 7, 19, 27, 29, 40, 1, 12, 36, 8, 24, 33, 38]}}
{"prediction": {"error_location": 0.4239157736301422, "repair_targets": [0.6605497598648071, 0.001838807831518352], "repair_candidates": [0.004855307284742594, 0.6605497598648071, 0.07023375481367111, 0.10120728611946106, 0.006085954140871763, 0.0017309875693172216, 0.001838807831518352, 0.00012459039862733334, 0.15026181936264038, 0.002725904807448387, 0.000153992761624977, 6.85748309479095e-05, 1.0645451766322367e-05, 0.0001526629930594936], "target_probs": 0.6623885631561279}}


{"result": {"time": "2021-02-21 13:31:02.170464", "n_pass": [351, 101, 27], "n_token": 40, "loss": [0.7412683963775635, 0.4593099355697632], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "(", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 35, "repair_targets": [3, 20], "repair_candidates": [3, 20, 7, 18, 26, 28, 39, 1, 12, 35, 8, 23, 32, 37]}}
{"prediction": {"error_location": 0.476509153842926, "repair_targets": [0.6245405673980713, 0.00717886071652174], "repair_candidates": [0.005664326250553131, 0.6245405673980713, 0.066398024559021, 0.11566348373889923, 0.007562687154859304, 0.00672465143725276, 0.00717886071652174, 0.00011604853352764621, 0.16300681233406067, 0.0028005784843117, 0.00015956659626681358, 5.094298830954358e-05, 8.493073437421117e-06, 0.00012502637400757521], "target_probs": 0.6317194104194641}}


{"result": {"time": "2021-02-21 13:31:02.240916", "n_pass": [352, 102, 28], "n_token": 39, "loss": [0.5754832029342651, 0.45119062066078186], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "==", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 34, "repair_targets": [3, 19], "repair_candidates": [3, 19, 7, 17, 25, 27, 38, 1, 12, 34, 8, 22, 31, 36]}}
{"prediction": {"error_location": 0.5624330639839172, "repair_targets": [0.6162878274917603, 0.020581629127264023], "repair_candidates": [0.0037174175959080458, 0.6162878274917603, 0.01819714345037937, 0.013311352580785751, 0.0024489802308380604, 0.015376190654933453, 0.020581629127264023, 5.945111843175255e-05, 0.3055097162723541, 0.004388473462313414, 4.2491843487368897e-05, 1.8976077626575716e-05, 3.0395324301935034e-06, 5.7274377468274906e-05], "target_probs": 0.6368694305419922}}


{"result": {"time": "2021-02-21 13:31:02.310506", "n_pass": [354, 103, 29], "n_token": 38, "loss": [0.45885956287384033, 0.47173482179641724], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", ")", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 33, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 24, 26, 37, 1, 12, 33, 8, 21, 30, 35]}}
{"prediction": {"error_location": 0.6320040225982666, "repair_targets": [0.5949240922927856, 0.028994861990213394], "repair_candidates": [0.002253494691103697, 0.5949240922927856, 0.012592436745762825, 0.009978397749364376, 0.001567262108437717, 0.02148577943444252, 0.028994861990213394, 2.5794366592890583e-05, 0.323081910610199, 0.005006684456020594, 2.9537533919210546e-05, 1.2798934221791569e-05, 2.1607804683299037e-06, 4.478741902858019e-05], "target_probs": 0.6239189505577087}}


{"result": {"time": "2021-02-21 13:31:02.380740", "n_pass": [356, 104, 30], "n_token": 37, "loss": [0.6909734606742859, 0.3543497622013092], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", ":", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 32, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 23, 25, 36, 1, 12, 32, 8, 20, 29, 34]}}
{"prediction": {"error_location": 0.5010880827903748, "repair_targets": [0.6987574100494385, 0.0028720805421471596], "repair_candidates": [0.0035198209807276726, 0.6987574100494385, 0.013717514462769032, 0.015639428049325943, 0.002540609799325466, 0.017360907047986984, 0.0028720805421471596, 5.456338112708181e-05, 0.23946033418178558, 0.005949227139353752, 3.931979517801665e-05, 2.0911204046569765e-05, 3.3826049730123486e-06, 6.439071876229718e-05], "target_probs": 0.7016295194625854}}


{"result": {"time": "2021-02-21 13:31:02.452967", "n_pass": [357, 105, 31], "n_token": 36, "loss": [0.6323676705360413, 0.1948787271976471], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "#UNINDENT#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 31, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 22, 24, 35, 1, 12, 31, 8, 19, 28, 33]}}
{"prediction": {"error_location": 0.5313323140144348, "repair_targets": [0.8226068019866943, 0.0003276526986155659], "repair_candidates": [0.0025322092697024345, 0.8226068019866943, 0.006032728590071201, 0.00915912352502346, 0.0008729918044991791, 0.0033289180137217045, 0.0003276526986155659, 0.0002689817629288882, 0.1447458565235138, 0.010054399259388447, 1.698576488706749e-05, 8.047784831433091e-06, 1.6631190646876348e-06, 4.370118767837994e-05], "target_probs": 0.8229344487190247}}


{"result": {"time": "2021-02-21 13:31:02.591512", "n_pass": [360, 107, 32], "n_token": 35, "loss": [0.4366486668586731, 0.2523716986179352], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#NEWLINE#", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 30, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 21, 23, 34, 1, 12, 30, 8, 19, 27, 32]}}
{"prediction": {"error_location": 0.6461983919143677, "repair_targets": [0.7765134572982788, 0.00044245304889045656], "repair_candidates": [0.0030239783227443695, 0.7765134572982788, 0.006982515100389719, 0.011964594945311546, 0.001208120840601623, 0.0036019275430589914, 0.00044245304889045656, 0.0010145420674234629, 0.18984641134738922, 0.005341256503015757, 1.4679423657071311e-05, 5.7593933888711035e-06, 1.2040036381222308e-06, 3.907776408595964e-05], "target_probs": 0.7769559025764465}}


{"result": {"time": "2021-02-21 13:31:02.728144", "n_pass": [364, 109, 33], "n_token": 34, "loss": [0.7015936374664307, 0.23699858784675598], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 29, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 21, 23, 33, 1, 12, 29, 8, 19, 26, 31]}}
{"prediction": {"error_location": 0.4957945644855499, "repair_targets": [0.7886041402816772, 0.00038825118099339306], "repair_candidates": [0.002393603790551424, 0.7886041402816772, 0.007287437096238136, 0.009893476963043213, 0.0007993241306394339, 0.0027192598208785057, 0.00038825118099339306, 0.0009464192553423345, 0.18539968132972717, 0.0015171333216130733, 1.5097522918949835e-05, 6.335019406833453e-06, 8.859016134010744e-07, 2.8927743187523447e-05], "target_probs": 0.7889924049377441}}


{"result": {"time": "2021-02-21 13:31:02.796219", "n_pass": [365, 110, 34], "n_token": 33, "loss": [0.5865182280540466, 0.1475471407175064], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "==", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 28, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 21, 23, 32, 1, 12, 28, 8, 19, 25, 30]}}
{"prediction": {"error_location": 0.5562607049942017, "repair_targets": [0.8624990582466125, 0.0003227027482353151], "repair_candidates": [0.0026794681325554848, 0.8624990582466125, 0.01242309994995594, 0.028339385986328125, 0.0012732692994177341, 0.003270278451964259, 0.0003227027482353151, 0.0005634963745251298, 0.08761768788099289, 0.0009186193929053843, 4.553466715151444e-05, 6.548932560690446e-06, 1.1185987887074589e-06, 3.972911144956015e-05], "target_probs": 0.8628217577934265}}


{"result": {"time": "2021-02-21 13:31:03.067312", "n_pass": [371, 114, 35], "n_token": 32, "loss": [0.3019667863845825, 0.1638420820236206], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "#NEWLINE#", "counter"]}}
{"position": {"error_location": 28, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 21, 23, 31, 1, 12, 28, 8, 19, 25, 29]}}
{"prediction": {"error_location": 0.7393627166748047, "repair_targets": [0.8485214710235596, 0.00035460785147733986], "repair_candidates": [0.0045693605206906796, 0.8485214710235596, 0.0061516473069787025, 0.04477602243423462, 0.0015890412032604218, 0.004422989673912525, 0.00035460785147733986, 0.0007774772238917649, 0.08765963464975357, 0.000996464747004211, 3.966235453845002e-05, 9.490747288509738e-06, 1.823026423153351e-06, 0.0001302985183428973], "target_probs": 0.8488760590553284}}


{"result": {"time": "2021-02-21 13:31:03.134030", "n_pass": [373, 115, 36], "n_token": 31, "loss": [0.17974336445331573, 0.2640121877193451], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", ",", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 28, "repair_targets": [3, 18], "repair_candidates": [3, 18, 7, 17, 21, 23, 30, 1, 12, 28, 8, 19, 25, 29]}}
{"prediction": {"error_location": 0.8354846239089966, "repair_targets": [0.7677175402641296, 0.00024664404918439686], "repair_candidates": [0.004175068344920874, 0.7677175402641296, 0.008225832134485245, 0.07386772334575653, 0.0011830410221591592, 0.0030136993154883385, 0.00024664404918439686, 0.0006133179413154721, 0.13970865309238434, 0.0012080707820132375, 2.9509812520700507e-05, 2.8615572773560416e-06, 9.268594567402033e-07, 7.049443411233369e-06], "target_probs": 0.7679641842842102}}


{"result": {"time": "2021-02-21 13:31:03.267393", "n_pass": [377, 117, 37], "n_token": 30, "loss": [0.16868357360363007, 0.19312356412410736], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ")", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 27, "repair_targets": [2, 17], "repair_candidates": [2, 17, 6, 16, 20, 22, 29, 1, 11, 27, 7, 18, 24, 28]}}
{"prediction": {"error_location": 0.8447762727737427, "repair_targets": [0.8243408799171448, 3.9245733205461875e-05], "repair_candidates": [0.01005502324551344, 0.8243408799171448, 0.003078979440033436, 0.10121002048254013, 0.00040842773159965873, 0.00035618225228972733, 3.9245733205461875e-05, 0.00013736083928961307, 0.06013870984315872, 0.00020190159557387233, 2.7286885597277433e-05, 2.064157342829276e-06, 5.89451190080581e-07, 3.476908204902429e-06], "target_probs": 0.824380099773407}}


{"result": {"time": "2021-02-21 13:31:03.333216", "n_pass": [379, 118, 38], "n_token": 29, "loss": [0.2732260525226593, 0.21076563000679016], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "#NEWLINE#", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 26, "repair_targets": [2, 16], "repair_candidates": [2, 16, 5, 15, 19, 21, 28, 1, 10, 26, 6, 17, 23, 27]}}
{"prediction": {"error_location": 0.7609207034111023, "repair_targets": [0.8097267746925354, 0.00023709615925326943], "repair_candidates": [0.014966615475714207, 0.8097267746925354, 0.008742137812077999, 0.06006910279393196, 0.0010846764780580997, 0.0013448940590023994, 0.00023709615925326943, 0.0008806158439256251, 0.10210978984832764, 0.0007210967596620321, 9.831135685089976e-05, 8.487120794598013e-06, 1.8929092675534775e-06, 8.533463187632151e-06], "target_probs": 0.8099638819694519}}


{"result": {"time": "2021-02-21 13:31:03.463417", "n_pass": [381, 120, 39], "n_token": 28, "loss": [0.20061177015304565, 0.16673403978347778], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "=", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 25, "repair_targets": [2, 15], "repair_candidates": [2, 15, 4, 14, 18, 20, 27, 1, 9, 25, 5, 16, 22, 26]}}
{"prediction": {"error_location": 0.8182300329208374, "repair_targets": [0.8462656140327454, 0.00015910861839074641], "repair_candidates": [0.019296852871775627, 0.8462656140327454, 0.002005161251872778, 0.016748936846852303, 0.0012763096019625664, 0.0008037324878387153, 0.00015910861839074641, 0.0005038722883909941, 0.11232896894216537, 0.0005413385224528611, 5.663511547027156e-05, 5.784901532024378e-06, 1.3873094530936214e-06, 6.306060186034301e-06], "target_probs": 0.8464246988296509}}


{"result": {"time": "2021-02-21 13:31:03.528445", "n_pass": [384, 121, 40], "n_token": 27, "loss": [0.1376427263021469, 0.32860419154167175], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "=", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 24, "repair_targets": [2, 14], "repair_candidates": [2, 14, 4, 13, 17, 19, 26, 1, 8, 24, 5, 15, 21, 25]}}
{"prediction": {"error_location": 0.8714099526405334, "repair_targets": [0.7197881937026978, 0.00013970726286061108], "repair_candidates": [0.045052602887153625, 0.7197881937026978, 0.002432565437629819, 0.023847758769989014, 0.002255038358271122, 0.00041134891216643155, 0.00013970726286061108, 0.0008311193669214845, 0.20444796979427338, 0.0006456376286223531, 0.00012521128519438207, 8.515129593433812e-06, 2.227660161224776e-06, 1.211506241816096e-05], "target_probs": 0.7199279069900513}}


{"result": {"time": "2021-02-21 13:31:03.659031", "n_pass": [386, 123, 41], "n_token": 26, "loss": [0.12480470538139343, 0.6035552024841309], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", ",", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 23, "repair_targets": [2, 13], "repair_candidates": [2, 13, 4, 12, 16, 18, 25, 1, 7, 23, 5, 14, 20, 24]}}
{"prediction": {"error_location": 0.8826692700386047, "repair_targets": [0.546645998954773, 0.00021798441594000906], "repair_candidates": [0.10043065994977951, 0.546645998954773, 0.001573016750626266, 0.0029372607823461294, 0.00763718830421567, 0.0011120433919131756, 0.00021798441594000906, 0.0009554773569107056, 0.33743515610694885, 0.0008777813636697829, 0.0001362613693345338, 2.0976403902750462e-05, 3.918109996448038e-06, 1.6312698789988644e-05], "target_probs": 0.5468639731407166}}


{"result": {"time": "2021-02-21 13:31:03.722691", "n_pass": [388, 124, 42], "n_token": 25, "loss": [0.06234782934188843, 0.6072545051574707], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", "previous_track", "None", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 22, "repair_targets": [2, 12], "repair_candidates": [2, 12, 4, 11, 15, 17, 24, 1, 7, 22, 5, 13, 19, 23]}}
{"prediction": {"error_location": 0.9395561218261719, "repair_targets": [0.5446767210960388, 0.0001679676934145391], "repair_candidates": [0.03331536427140236, 0.5446767210960388, 0.0004913187003694475, 0.0002961350546684116, 0.0010531449224799871, 0.001688231946900487, 0.0001679676934145391, 0.0009953535627573729, 0.4168807864189148, 0.000364921084837988, 5.795852848677896e-05, 5.112960934638977e-06, 1.2436125871317927e-06, 5.8185119087283965e-06], "target_probs": 0.5448446869850159}}


{"result": {"time": "2021-02-21 13:31:03.847817", "n_pass": [390, 126, 43], "n_token": 24, "loss": [0.14097483456134796, 0.5435366630554199], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", "previous_track", ".", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 21, "repair_targets": [2, 11], "repair_candidates": [2, 11, 4, 10, 14, 16, 23, 1, 7, 21, 5, 12, 18, 22]}}
{"prediction": {"error_location": 0.8685111403465271, "repair_targets": [0.5803899765014648, 0.0003009592182934284], "repair_candidates": [0.10544897615909576, 0.5803899765014648, 0.0013041817583143711, 0.006797577254474163, 0.05886640399694443, 0.0016382612520828843, 0.0003009592182934284, 0.0014719070168212056, 0.24303504824638367, 0.0006675627082586288, 6.337784725474194e-05, 7.429939159919741e-06, 1.5592368072248064e-06, 6.7598257373902015e-06], "target_probs": 0.5806909203529358}}


{"result": {"time": "2021-02-21 13:31:03.910578", "n_pass": [391, 127, 44], "n_token": 23, "loss": [0.0472063347697258, 0.5712953805923462], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", "previous_track", "counter", "index", "track", "#NEWLINE#", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 20, "repair_targets": [2, 10], "repair_candidates": [2, 10, 4, 9, 13, 15, 22, 1, 7, 20, 5, 11, 17, 21]}}
{"prediction": {"error_location": 0.9538905620574951, "repair_targets": [0.5647005438804626, 9.281861275667325e-05], "repair_candidates": [0.0813014879822731, 0.5647005438804626, 0.0009313689661212265, 0.0013860597973689437, 0.006325042340904474, 4.411447298480198e-05, 9.281861275667325e-05, 0.0013788074720650911, 0.34312641620635986, 0.0005125365569256246, 0.00015613797586411238, 1.3534262507164385e-05, 4.555848136078566e-06, 2.65909984591417e-05], "target_probs": 0.5647933483123779}}


{"result": {"time": "2021-02-21 13:31:03.972845", "n_pass": [395, 128, 45], "n_token": 22, "loss": [0.8125247359275818, 0.1808992326259613], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", "previous_track", "counter", "index", "track", "counter", ">", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 19, "repair_targets": [2, 10], "repair_candidates": [2, 10, 4, 9, 12, 14, 21, 1, 7, 19, 5, 11, 16, 20]}}
{"prediction": {"error_location": 0.44373631477355957, "repair_targets": [0.8342540264129639, 0.00026542131672613323], "repair_candidates": [0.1282595992088318, 0.8342540264129639, 0.001876929309219122, 0.003306154627352953, 0.021632645279169083, 0.00011098077084170654, 0.00026542131672613323, 0.0018054478568956256, 0.004732466768473387, 0.0004369229427538812, 0.002407215302810073, 0.0007426691590808332, 6.036326158209704e-05, 0.0001092676684493199], "target_probs": 0.8345194458961487}}


{"result": {"time": "2021-02-21 13:31:04.037102", "n_pass": [397, 129, 46], "n_token": 21, "loss": [1.0572651624679565, 0.19158825278282166], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", "previous_track", "counter", "index", "track", "counter", "counter", "#UNINDENT#", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 18, "repair_targets": [2, 10], "repair_candidates": [2, 10, 4, 9, 12, 13, 20, 1, 7, 18, 5, 11, 15, 19]}}
{"prediction": {"error_location": 0.3474045991897583, "repair_targets": [0.8253701329231262, 0.00027660001069307327], "repair_candidates": [0.11263038218021393, 0.8253701329231262, 0.0014804336242377758, 0.0032696593552827835, 0.05049640312790871, 0.00017073919298127294, 0.00027660001069307327, 0.0010468503460288048, 0.0008718597237020731, 0.00044659970444627106, 0.0032222329173237085, 0.0006094719865359366, 4.107662971364334e-05, 6.757862138329074e-05], "target_probs": 0.8256467580795288}}


{"result": {"time": "2021-02-21 13:31:04.098590", "n_pass": [399, 130, 47], "n_token": 20, "loss": [0.9676076173782349, 0.14089642465114594], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "TrackPlaylistRelationship", "self", "previous_track", "counter", "index", "track", "counter", "counter", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 17, "repair_targets": [2, 10], "repair_candidates": [2, 10, 4, 9, 12, 13, 19, 1, 7, 17, 5, 11, 14, 18]}}
{"prediction": {"error_location": 0.3799910545349121, "repair_targets": [0.8684296011924744, 0.0001496921177022159], "repair_candidates": [0.08039254695177078, 0.8684296011924744, 0.0027028508484363556, 0.005358263850212097, 0.037668559700250626, 0.00013322060112841427, 0.0001496921177022159, 0.00027900689747184515, 0.00035334686981514096, 0.00037159770727157593, 0.003314858302474022, 0.0007481473730877042, 3.794256554101594e-05, 6.0403959651011974e-05], "target_probs": 0.8685792684555054}}


{"result": {"time": "2021-02-21 13:31:04.403809", "n_pass": [412, 135, 48], "n_token": 19, "loss": [1.245033621788025, 0.15199846029281616], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "self", "previous_track", "counter", "index", "track", "counter", "counter", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 16, "repair_targets": [2, 9], "repair_candidates": [2, 9, 4, 8, 11, 12, 18, 1, 6, 16, 5, 10, 13, 17]}}
{"prediction": {"error_location": 0.2879312336444855, "repair_targets": [0.8589016199111938, 8.797378541203216e-05], "repair_candidates": [0.12852589786052704, 0.8589016199111938, 0.003514073556289077, 0.0028616159688681364, 0.002859685570001602, 8.83955362951383e-05, 8.797378541203216e-05, 0.00022712671488989145, 0.0004451961431186646, 0.00031464570201933384, 0.0015504752518609166, 0.0005567235057242215, 2.788399979181122e-05, 3.8633690564893186e-05], "target_probs": 0.8589895963668823}}


{"result": {"time": "2021-02-21 13:31:04.464066", "n_pass": [414, 136, 49], "n_token": 18, "loss": [0.75955730676651, 0.11211791634559631], "accuracy": [0.0, 1.0, 1.0, 1.0]}}
{"sample": {"has_bug": true, "source_tokens": ["#NEWLINE#", "self", "index", ":", "counter", "track", "self", "counter", "index", "track", "counter", "counter", "track", "=", "==", "self", "track", "counter"]}}
{"position": {"error_location": 15, "repair_targets": [2, 8], "repair_candidates": [2, 8, 4, 7, 10, 11, 17, 1, 6, 15, 5, 9, 12, 16]}}
{"prediction": {"error_location": 0.4678734540939331, "repair_targets": [0.893811821937561, 0.0001270309294341132], "repair_candidates": [0.0884154736995697, 0.893811821937561, 0.0036532750818878412, 0.0036790426820516586, 0.0015167009551078081, 0.00010071644646814093, 0.0001270309294341132, 0.00026850574067793787, 0.0003781990671996027, 0.000344820466125384, 0.007260757498443127, 0.00037286896258592606, 2.740563650149852e-05, 4.347292269812897e-05], "target_probs": 0.8939388394355774}}




Minimal simplified tokens:

['#NEWLINE#', 'self', 'index', ':', 'counter', 'track', 'self', 'counter', 'index', 'track', 'counter', 'counter', 'track', '=', '==', 'self', 'track', 'counter']
